# 面经总结

## C++语言基础

### 一.关键字等

#### 1.static 关键字的作用 （静态修饰）

1、全局静态变量

3、静态函数

默认的函数时 extren 的。 静态函数和静态变量 都是在该页文件中可见，在其他文件中不可见，避免重复名字调用。

2、局部静态变量

一直存在，每次调用时值不变  **只进行一次初始化。**



4、类的静态成员变量：类的静态成员变量是和类相关的，而不是和类的对象相关的。即使没有类的对象，也可以使用 static 成员变量。声明为 static 的成员变量还具有持久性，**即不因为对象是否存在而改变自身的存在性质，**对于某些数据需要全体用户共享时，使用 static 是个不错的选择。

5、类的静态成员函数：作用 调用不需要成员名 即可调用函数。  只能操作静态成员，想操作对象，需要传入对象的引用。

（类内声明类外初始化）



#### 2.const 关键字作用 （常量修饰）

常量在C++里的定义就是一个  const 加上对象类型，常量定义必须**初始化**。

对于局部对象，常量存放在栈区，

对于全局对象，常量存放在常量存储区。

对于字面值常量，常量存放在常量存储区。



const 成员变量：const 成员变量，只在某个对象生命周期内是常量，而对于整个类而言却是可以改变的

const 成员函数：const 成员函数的主要目的是防止成员函数修改对象的内容。



​    常量对象可以调用类中的 const 成员函数，但不能调用非 const 成员函数；
非常量对象可以调用类中的 const 成员函数，也可以调用非 const 成员函数

#### 3.define 关键字

是一个**宏定义**的*关键字*，它的用法如下：*define* 常量名 值 该句使用在程序开头，

整个程序中该常量在预编译的时候用后面的值作**简单替换**





### 二.     指针    内存相关

#### 1.内存分配情况

1）栈：由编译器管理分配和回收，存放局部变量和函数参数；            （函数**栈空间最大值**为1m  但是可以调整）
2）堆：由程序员管理 new malloc delect free 进行分配和回收，空间较大，但是
可能出现内存泄漏和空闲碎片的问题；
3）全局／静态存储区：分为初始化和未初始化两个相邻的区域，存储初始化和
未初始化的全局变量和静态变量；
4）常量存储区：存储常量，一般不允许修改；
5）代码区：存储程序的二进制代码。



#### 2.引用和指针

1、引用：相当于一个指针常量 * const  相当于别名

2、指针：存储指向其他数据的地址

区别：

1、指针有自己的一块空间，而引用只是一个别名；

2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

3、指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；

4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；

5、可以有const指针，但是没有const引用；

6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

7、指针可以有多级指针（**p），而引用至于一级；

8、指针和引用使用++运算符的意义不一样；

9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

#### 3.指针和数组区别

![2e4f186fe680f8b118327c028a1a06e](C:\Users\singer\AppData\Local\Temp\WeChat Files\2e4f186fe680f8b118327c028a1a06e.png)



#### 4.内存泄漏定义

定义：内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了



#### 5.智能指针 相关

C++里面的四个智能指针: auto_ptr,unique_ptr ， shared_ptr, weak_ptr, 其中后三个是c++11支持，并且第一个已经被11弃用。



##### 请你回答一下智能指针有没有内存泄露的情况（牛客）









#### 6、野指针

野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针





#### *7、请你说一下函数指针

参考回答：

1、定义

函数指针是指向函数的指针变量。

函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。

C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

2、用途：

调用函数和做函数的参数，比如回调函数。

3、示例：

char * fun(char * p)  {…}    // 函数fun

char * (*pf)(char * p);       // 函数指针pf

pf = fun;            // 函数指针pf指向函数fun

pf(p);            // 通过函数指针pf调用函数fun





### 三.类与对象相关



#### 1.类的三大特性

封装 继承 多态



#### 2.   多态  相关

##### （1）重写和重载 重定义

重载：是指同一可访问区内被声明的几个具有不同参数列表的同名函数，依赖于 C++函数名字的修饰会将参数加在后面，可以是参数类型，个数，顺序的不同。根据参数列表决定调用哪个函数，重载不关心函数的返回类型。
重写（覆盖）：派生类中重新定义父类中除了函数体外完全相同的虚函数，注意被重写的函数不能是 static 的，一定要是虚函数，且其他一定要完全相同。要注意，重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的，尽管virtual中是private的，派生类中重写可以改为public。
重定义（隐藏）：派生类重新定义父类中相同名字的非 virtual 函数，参数列表和返回类型都可以不同，即父类中除了定义成 virtual 且完全相同的同名函数才不会被派生类中的同名函数所隐藏（重定义）。

##### （2）虚函数（虚函数表）

虚函数：在父类函数前加 virtual   在子类中 重写相同的 函数  ，会根据对象类型进行函数调用

纯虚函数： 因为父类虚函数无意义 就不进行定义 使其=0   变成抽象类  如果子类也不进行重写 也为抽象类  抽象类不可以实例化对象



##### *● 请你来说一下静态函数和虚函数的区别

参考回答：

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销



#### *3.构造函数 析构函数相关





● 请你来说一下C++中析构函数的作用

参考回答：

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。







析构函数一般写成虚函数的原因
为了降低内存泄漏的可能性。举例来说就是，一个基类的指针指向一个派生
类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那
么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数
（该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的

析构，派生类的自身内容将无法被析构，造成内存泄漏。如果基类的析构函数定
义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行
基类的析构函数，成功释放内存。







● 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数

参考回答：

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。









*？  构造函数为什么一般不定义为虚函数
1）虚函数调用只需要知道“部分的”信息，即只需要知道函数接口，而不需要知
道对象的具体类型。但是，我们要创建一个对象的话，是需要知道对象的完整信
息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义
成虚函数；
2）而且从目前编译器实现虚函数进行多态的方式来看，虚函数的调用是通过实
例化之后对象的虚函数表指针来找到虚函数的地址进行调用的，如果说构造函数
是虚的，那么虚函数表指针则是不存在的，无法找到对应的虚函数表来调用虚函
数，那么这个调用实际上也是违背先实例化后调用的准则的。

30. 构造函数或析构函数中调用虚函数会怎样
    实际上是不应该在构造函数或析构函数中调用虚函数的，因为这样的调用其
    实并不会带来所想要的效果。举例来说就是，有一个交易记录的基类，基类中定
    义了一个纪录本身信息的虚函数 log()，在基类的构造函数中调用了这个虚函数。
    派生类中重写了这个虚函数，我们期望着根据对象的真实类型不同，而调用各自
    实现的虚函数，但实际上当我们创建一个派生类对象时，首先会创建派生类的基
    类部分，执行基类的构造函数，此时，派生类的自身部分还没有被初始化，对于
    这种还没有初始化的东西，C++选择当它们还不存在作为一种安全的方法。也就
    是说构造派生类的基类部分是，编译器会认为这就是一个基类类型的对象，然后
    调用基类类型中的虚函数实现，并没有按照我们想要的方式进行。即对象在派生
    类构造函数执行前并不会成为一个派生类对象。
    在析构函数中也是同理，派生类执行了析构函数后，派生类的自身成员呈现
    未定义的状态，那么在执行基类的析构函数中是不可能调用到派生类重写的方法
    的。所以说，我们不应该在构在函数或析构函数中调用虚函数，就算调用一般也
    不会达到我们想要的结果。
    补充： ：如果说非要在构造函数或析构函数中调用一个函数，那么不要将这个函数
    定义成 virtual 的，可以给函数提供一个参数，让派生类可以把自身特别的信息
    传递给基类，这样就可以实现了。即“令派生类将必要的构造信息向上传递给基
    类的构造函数，因为无法使用虚函数从基类向下调用”。

    



#### 4。深拷贝

当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数－即浅拷贝，它能够完成成员的一一复制。当数据成
员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致指野指针的问题。所以，这时必需采用深拷贝。深拷贝与浅拷贝之间的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而也就解决来野指针的问题。简而言之，当数据成员中有指针时，必需要用深拷贝更加安全。



####  5.介绍 C++ 所有的构造函数

类的对象被创建时，编译系统为对象分配内存空间，并自动调用构造函数，由构
造函数完成成员的初始化工作，即，构造函数的作用：初始化对象的数据成员。

1）无参数构造函数：即默认构造函数，如果没有明确写出无参数构造函数，编
译器会自动生成默认的无参数构造函数，函数为空，什么也不做，如果不想使用
自动生成的无参构造函数，必需要自己显示写出一个无参构造函数。
2）一般构造函数：也称重载构造函数，一般构造函数可以有各种参数形式，一
个类可以有多个一般构造函数，前提是参数的个数或者类型不同，创建对象时根
据传入参数不同调用不同的构造函数。
3）拷贝构造函数：拷贝构造函数的函数参数为对象本身的引用，用于根据一个
已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在的对象的数
据成员的值一一复制到新创建的对象中。如果没有显示的写拷贝构造函数，则系
统会默认创建一个拷贝构造函数，但当类中有指针成员时，最好不要使用编译器
提供的默认的拷贝构造函数，最好自己定义并且在函数中执行深拷贝。
4）类型转换构造函数：根据一个指定类型的对象创建一个本类的对象，也可以
算是一般构造函数的一种，这里提出来，是想说有的时候不允许默认转换的话，
要记得将其声明为 explict 的，来阻止一些隐式转换的发生。
赋值运算符的重载：注意，这个类似拷贝构造函数，将＝右边的本类对象的值复
制给＝左边的对象，它不属于构造函数，＝左右两边的对象必需已经被创建。如
果没有显示的写赋值运算符的重载，系统也会生成默认的赋值运算符，做一些基
本的拷贝工作。这里区分 A a1, A a2; a1 = a2;//调用赋值运算符
A a3 = a1; //调用拷贝构造函数，因为进行的是初始化工作，a3 并未存在。



什么情况下会调用拷贝构造函数( 三种情况)
类的对象需要拷贝时，拷贝构造函数将会被调用，以下的情况都会调用拷贝构造
函数：
1）一个对象以值传递的方式传入函数体，需要拷贝构造函数创建一个临时对象
压入到栈空间中。
2）一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时
对象作为返回值。
3）一个对象需要通过另外一个对象进行初始化。



#### 6.成员初始化列表的概念，为什么用成员初始化列表会快一些( 性能优势) ？

1）概念：在类的构造函数中，不再函数体内对变量赋值，而在参数列表后，跟
一个冒号和初始化列表。
2）使用初始化列表的必要性：○
1 如果类中有 const 成员或引用类型的成员，由于
const 对象和引用类型都只能初始化，不支持赋值，所以这种情况必需使用初始
化列表；○
2 类中含有其它类作为成员，作为成员的类将赋值操作禁止了，也必需
用初始化列表；
3）使用初始化列表的性能优势：从上面的必要性可以看出适用更多的情况。另
外，如果类中包含其它类，在进入构造函数时，实际上已经构造了其它类的临时
对象，然后在构造函数中再进行赋值操作，完成完整的构造函数。但如果使用初
始化列表，则可以省去构造临时对象，直接完成初始化工作，效率更高。
4）注意事项：○
1 构造对象的顺序按照成员属性声明的顺序，而不是成员初始化
列表的顺序；○
2 静态对象只构造一次；○ 3 所有全局对象在 main()函数之前被构造，
且一般按照声明的顺序构造。



### 四.stl











### 五.其他

#### *C++ 的四种强制转换

C++的四种强制转换包括：static_cast, dynamic_cast, const_cast, reinterpret_cast
○
1 static_cast：明确指出类型转换，一般建议将隐式转换都替换成显示转换，因为
没有动态类型检查，上行转换（派生类->基类）安全，下行转换（基类->派生类）
不安全，所以主要执行非多态的转换操作；
○
2 dynamic_cast：专门用于派生类之间的转换，type-id 必须是类指针，类引用或
void*，对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而
static_cast，当类型不一致时，转换过来的事错误意义的指针，可能造成非法访
问等问题。
○
3 const_cast：专门用于 const 属性的转换，去除 const 性质，或增加 const 性质，
是四个转换符中唯一一个可以操作常量的转换符

4 reinterpret_cast：不到万不得已，不要使用这个转换符，高危操作。使用特点：
◇
a 从底层对数据进行重新解释，依赖具体的平台，可移植性差；◇ b 可以将整形转
换为指针，也可以把指针转换为数组；◇
c 可以在指针和引用之间进行肆无忌惮的
转换





## 计算机网络

### 一、tcp协议

#### 1.请回答OSI七层模型和TCP/IP四层模型

**OSI七层模型及其包含的协议如下:**

物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45

数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP

网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP

传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP

会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS

表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII

应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS

**TCP/IP 4层模型包括：**

应用层:HTTP DNS SMTP     telnet ftp email

传输层:TCP UDP					

网络层:IP ARP ICMP	igmp

网络接口层（数据链路层）：MAC VLAN     设备驱动程序及网卡



#### 2.TCP 怎么保持可靠性\握手\挥手\状态转义(概念)

书221.





#### 3.三次握手和四次挥手的原因

2）三次握手原因：

三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。

服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。



4）为什么TCP协议终止链接要四次？

1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。

2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。

3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。

4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。



5）2MSL意义：

1、保证最后一次握手报文能到B，能进行超时重传。

2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。



为什么用三次握手
本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：
1.客户端发送syn0给服务器
2.服务器收到syn0，回复ack(syn0+1)
3.服务器发送syn1
3.客户端收到syn1，回复ack(syn1+1)
因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。





两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常

不用四次：
本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：
1.客户端发送syn0给服务器
2.服务器收到syn0，回复ack(syn0+1)
3.服务器发送syn1
4.客户端收到syn1，回复ack(syn1+1)
因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。



三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。



四次挥手的原因：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。



#### 4.TCP UDP区别







#### 5.拥塞控制







## 操作系统

### 一、进程 线程

#### （1)线程    进程基本概念

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；

线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。





#### （2）线程与进程 区别







#### （3）各同步通信方式







### 三、锁相关







### 三.内存控制













### 





### 





























